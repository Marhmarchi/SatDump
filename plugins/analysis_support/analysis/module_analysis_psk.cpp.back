#include "module_analysis_psk.h"
#include "common/dsp/buffer.h"
#include "common/dsp/fft/fft_pan.h"
#include "common/dsp/io/wav_writer.h"
#include "common/dsp/path/splitter.h"
#include "common/dsp/utils/real_to_complex.h"
#include "common/utils.h"
#include "common/widgets/fft_plot.h"
#include "core/module.h"
#include "imgui/imgui_markdown.h"
#include "logger.h"
#include "imgui/imgui.h"
#include "core/config.h"


#include "common/dsp/filter/firdes.h"
#include <complex.h>
#include <cstdint>
#include <fstream>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <volk/volk.h>
#include <volk/volk_complex.h>

//#define BUFFER_SIZE 8192

namespace analysis
{
	AnalysisPsk::AnalysisPsk(std::string input_file, std::string output_file_hint, nlohmann::json parameters)
		: BaseDemodModule(input_file, output_file_hint, parameters)//,
	{
		if (parameters.count("cutoff_freq") >0)
			d_cutoff_freq = parameters["cutoff_freq"].get<double>();
		else
			throw std::runtime_error("Cutoff frequency must be present!");

		if (parameters.count("transition_bw") >0)
			d_transition_bw = parameters["transition_bw"].get<double>();
		else
			throw std::runtime_error("Transition bandwidth must be present!");

		//exponent = satdump::config::main_cfg["user_interface"]["exponent"]["value"].get<int>();

		//enable_freq_scale;
		show_freq = true;
		
		MIN_SPS = 1;
		MAX_SPS = 1000.0;

	}

	void AnalysisPsk::init()
	{
		BaseDemodModule::initb();
///
//		// Low pass filter
		lpf = std::make_shared<dsp::FIRBlock<complex_t>>(agc->output_stream, dsp::firdes::low_pass(1.0, final_samplerate, d_cutoff_freq, d_transition_bw));
//
//		// Real To Complex
//		//rtc = std::make_shared<dsp::RealToComplexBlock>(res->output_stream);


	}

	AnalysisPsk::~AnalysisPsk()
	{
	}

	void AnalysisPsk::process()
	{
		if (input_data_type == DATA_FILE)
			filesize = file_source->getFilesize();
		else
			filesize = 0;

		if (output_data_type == DATA_FILE)
		{
			data_out = std::ofstream(d_output_file_hint + ".f32", std::ios::binary);
			d_output_files.push_back(d_output_file_hint + ".f32");
		}
	
		logger->info("Using input baseband" + d_input_file);
		logger->info("Saving processed to " + d_output_file_hint + ".f32");
		logger->info("Buffer size : " + std::to_string(d_buffer_size));

		time_t lastTime = 0;

		// Start
		BaseDemodModule::start();
		dsp::RationalResamplerBlock<complex_t> res(nullptr, 2, 1/*d_symbolrate, final_samplerate*/);
		//dsp::FIRBlock<complex_t> lpf(nullptr, dsp::firdes::low_pass(1.0, final_samplerate * 2, d_cutoff_freq, d_transition_bw));
		complex_t *work_buffer_in = dsp::create_volk_buffer<complex_t>(d_buffer_size);
		complex_t *work_buffer_out = dsp::create_volk_buffer<complex_t>(d_buffer_size);
		//res->start();
		lpf->start();
		fft_splitter->start();
		fft_proc->start();

		//Buffer
		complex_t *exp_output = new complex_t[d_buffer_size * 200];

		complex_t last_samp = 0;

		int exponent = 2;

		int final_data_size = 0;
	
		int dat_size = 0;
		while (demod_should_run())
		{
			dat_size = lpf->output_stream->read();

			if (dat_size <= 0)
			{
				lpf->output_stream->flush();
				continue;
			}

			int nout = res.process(lpf->output_stream->readBuf, dat_size, work_buffer_in);
			{
			volk_32fc_x2_multiply_32fc((lv_32fc_t *)exp_output, (lv_32fc_t *)work_buffer_in, (lv_32fc_t *)work_buffer_in, nout);
			for (int i = 2; i < exponent; i++) {
				volk_32fc_x2_multiply_32fc((lv_32fc_t *)exp_output, (lv_32fc_t *)exp_output, (lv_32fc_t *)work_buffer_in, nout);
			}
			}

			fft_splitter = std::make_shared<dsp::SplitterBlock>(lpf->output_stream);
			fft_splitter->add_output("lowPassFilter");
			fft_splitter->set_enabled("lowPassFilter", true);
                	
			fft_proc = std::make_shared<dsp::FFTPanBlock>(fft_splitter->get_output("lowPassFilter"));
			fft_proc->set_fft_settings(32768, final_samplerate, 120);
			//fft_proc->avg_num = 10;
			//fft_plot->enable_freq_scale;
			//fft_plot->bandwidth = final_samplerate;
			fft_plot = std::make_shared<widgets::FFTPlot>(fft_proc->output_stream->writeBuf, 32768, -20, 10, 10);

			if (output_data_type == DATA_FILE)
			{
				data_out.write((char *)exp_output, dat_size * sizeof(complex_t));
				final_data_size += dat_size * sizeof(complex_t);
			}
			else 
			{
				output_fifo->write((uint8_t *)output_buffer, dat_size * sizeof(complex_t));
				//logger->trace("%f", lpf->output_stream->readBuf);
			}

			lpf->output_stream->flush();

			if (input_data_type == DATA_FILE)
				progress = file_source->getPosition();

			if (time(NULL) % 10 == 0 && lastTime != time(NULL))
			{
				lastTime = time(NULL);
				logger->info("Progress " + std::to_string(round(((double)progress / (double)filesize) * 1000.0) / 10.0) + "%%");
			}
		}
		if (input_data_type == DATA_FILE)
			stop();
	}

	void AnalysisPsk::stop()
	{
		BaseDemodModule::stop();
		lpf->output_stream->stopReader();
		lpf->stop();
		fft_splitter->stop();
		fft_proc->stop();

		if (output_data_type == DATA_FILE)
			data_out.close();
	}
	
	void AnalysisPsk::drawUI(bool /*window*/)
	{
		ImGui::Begin("Analysis Module", NULL, ImGuiWindowFlags_NoScrollbar);
		ImGui::SetWindowSize(ImVec2(800,700), ImGuiCond_FirstUseEver);
		
		ImGui::BeginTabBar("##analysistabbar");
		{
			if (ImGui::BeginTabItem("Symbol Rate"))
			{

				ImGui::BeginGroup();

				ImGui::Button("Multiply Conjugate", {ImGui::GetWindowWidth() / 2 * ui_scale, 20 * ui_scale});
				ImGui::SameLine();
				ImGui::Button("Offset Multiply Conjugate", {ImGui::GetWindowWidth() / 2 * ui_scale, 20 * ui_scale});

				if (ImGui::BeginChild("##MulConj", ImVec2(ImGui::GetWindowWidth() / 2 * ui_scale, 400), false, ImGuiWindowFlags_None))
            			{
            			    fft_plot->draw({float(ImGui::GetWindowSize().x - 0), float(ImGui::GetWindowSize().y - 40 * ui_scale) * float(1.0)});
            			
            			    // Find "actual" left edge of FFT, before frequency shift.
            			    // Inset by 10% (819), then account for > 100% freq shifts via modulo
            			    //int pos = (abs((float)d_frequency_shift / (float)final_samplerate * 2/*d_samplerate*/) * (float)8192) + 819;
            			    //pos %= 8192;
            			    //
            			    //// Compute min and max of the middle 80% of original baseband
            			    //float min = 1000;
            			    //float max = -1000;
            			    //for (int i = 0; i < 6554; i++) // 8192 * 80% = 6554
            			    //{
            			    //    if (fft_proc->output_stream->writeBuf[pos] < min)
            			    //        min = fft_proc->output_stream->writeBuf[pos];
            			    //    if (fft_proc->output_stream->writeBuf[pos] > max)
            			    //        max = fft_proc->output_stream->writeBuf[pos];
            			    //    pos++;
            			    //    if (pos >= 8192)
            			    //        pos = 0;
            			    //}
				    ImGui::EndChild();
            			}
				ImGui::SameLine();


				if (ImGui::BeginChild("##MulConjOffset", ImVec2(ImGui::GetWindowWidth() / 2 * ui_scale, 400), false, ImGuiWindowFlags_None))
            			{
            			    fft_plot->draw({float(ImGui::GetWindowSize().x - 0), float(ImGui::GetWindowSize().y - 40 * ui_scale) * float(1.0)});
            			
            			    // Find "actual" left edge of FFT, before frequency shift.
            			    // Inset by 10% (819), then account for > 100% freq shifts via modulo
            			    //int pos = (abs((float)d_frequency_shift / (float)final_samplerate * 2/*d_samplerate*/) * (float)8192) + 819;
            			    //pos %= 8192;
            			
            			    //// Compute min and max of the middle 80% of original baseband
            			    //float min = 1000;
            			    //float max = -1000;
            			    //for (int i = 0; i < 6554; i++) // 8192 * 80% = 6554
            			    //{
            			    //    if (fft_proc->output_stream->writeBuf[pos] < min)
            			    //        min = fft_proc->output_stream->writeBuf[pos];
            			    //    if (fft_proc->output_stream->writeBuf[pos] > max)
            			    //        max = fft_proc->output_stream->writeBuf[pos];
            			    //    pos++;
            			    //    if (pos >= 8192)
            			    //        pos = 0;
            			    //}
				    ImGui::EndChild();
            			}

				ImGui::EndGroup();
				ImGui::EndTabItem();
			}

			if (ImGui::BeginTabItem("Modulation"))
			{


				ImGui::BeginGroup();

				ImGui::Button("Exponentiate", {ImGui::GetWindowWidth() * ui_scale, 20 * ui_scale});
				if (ImGui::BeginChild("##Exponen", ImVec2(ImGui::GetWindowWidth() * ui_scale, 400), false, ImGuiWindowFlags_None))
            			{
            			    fft_plot->draw({float(ImGui::GetWindowSize().x - 0), float(ImGui::GetWindowSize().y - 40 * ui_scale) * float(1.0)});
            			
            			    // Find "actual" left edge of FFT, before frequency shift.
            			    // Inset by 10% (819), then account for > 100% freq shifts via modulo
            			    //int pos = (abs((float)d_frequency_shift / (float)final_samplerate * 2/*d_samplerate*/) * (float)8192) + 819;
            			    //pos %= 8192;
            			
            			    //// Compute min and max of the middle 80% of original baseband
            			    //float min = 1000;
            			    //float max = -1000;
            			    //for (int i = 0; i < 6554; i++) // 8192 * 80% = 6554
            			    //{
            			    //    if (fft_proc->output_stream->writeBuf[pos] < min)
            			    //        min = fft_proc->output_stream->writeBuf[pos];
            			    //    if (fft_proc->output_stream->writeBuf[pos] > max)
            			    //        max = fft_proc->output_stream->writeBuf[pos];
            			    //    pos++;
            			    //    if (pos >= 8192)
            			    //        pos = 0;
            			    //}
				    ImGui::EndChild();
            			}

				ImGui::Button("Exponent number", {ImGui::GetWindowWidth() * ui_scale, 20 * ui_scale});
				enum exponent { exp_2, exp_4, exp_8, exp_16, exp_32, exp_64, expo_COUNT};
				static int expo = exp_2;
				const char* expon_numbers[expo_COUNT] = { "2", "4", "8", "16", "32", "64" };
				const char* expo_number = (expo >= 0 && expo < expo_COUNT) ? expon_numbers[expo] : "Unkown Exponent";
				ImGui::SliderInt("Exponent number", &expo, 0, expo_COUNT - 1, expo_number);

				//val = std::make_shared<int>(atoi(expo_number));

				//int exponent = atoi(expo_number);

				//std::stringstream expo_string;
				//expo_string << expo_number;

				//int expo_value;
				//expo_string >> expo_value;


				ImGui::EndGroup();
				ImGui::EndTabItem();
			}
		}

		ImGui::BeginGroup();
		{
			// Show SNR information
			//ImGui::Button("Signal", {200 * ui_scale, 20 * ui_scale});
			//snr_plot.draw(snr, peak_snr);
			if (!streamingInput)
				if (ImGui::Checkbox("Show FFT", &show_fft))
					fft_splitter->set_enabled("fft", show_fft);
		}
		ImGui::EndGroup();

		//ImGui::Begin("Analysis Plugin (very vey WIP)", NULL, window ? 0 : NOWINDOW_FLAGS);
		if (input_data_type == DATA_FILE)
			ImGui::ProgressBar((double)progress / (double)filesize, ImVec2(ImGui::GetWindowWidth() - 10, 20 * ui_scale));


		ImGui::EndTabBar();

		drawStopButton();

		//drawAnaFFT();
		ImGui::End();

		drawFFT();
	}

	
   // void AnalysisPsk::drawAnaFFT()
   //     {
   //         ImGui::SetNextWindowSize({400 * (float)ui_scale, (float)(400) * (float)ui_scale});
   //         if (ImGui::Begin("Baseband FFT", NULL, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize))
   //         {
   //             fft_plot->draw({float(ImGui::GetWindowSize().x - 0), float(ImGui::GetWindowSize().y - 40 * ui_scale) * float(1.0)});

   //             // Find "actual" left edge of FFT, before frequency shift.
   //             // Inset by 10% (819), then account for > 100% freq shifts via modulo
   //             int pos = (abs((float)d_frequency_shift / (float)final_samplerate/*d_samplerate*/) * (float)8192) + 819;
   //             pos %= 8192;

   //             // Compute min and max of the middle 80% of original baseband
   //             float min = 1000;
   //             float max = -1000;
   //             for (int i = 0; i < 6554; i++) // 8192 * 80% = 6554
   //             {
   //                 if (fft_proc->output_stream->writeBuf[pos] < min)
   //                     min = fft_proc->output_stream->writeBuf[pos];
   //                 if (fft_proc->output_stream->writeBuf[pos] > max)
   //                     max = fft_proc->output_stream->writeBuf[pos];
   //                 pos++;
   //                 if (pos >= 8192)
   //                     pos = 0;
   //             }

   //         }

   //         ImGui::End();
   //     }



	std::string AnalysisPsk::getID()
	{
		return "analysis_psk";
	}

	std::vector<std::string> AnalysisPsk::getParameters()
	{
		return {"cutoff_freq", "transition_bw"};
	}

	std::shared_ptr<ProcessingModule> AnalysisPsk::getInstance(std::string input_file, std::string output_file_hint, nlohmann::json parameters)
	{
		return std::make_shared<AnalysisPsk>(input_file, output_file_hint, parameters);
	}

}
